Java里方法重写override与方法重载overload有什么区别？
	1、相同点

		方法重写override与方法重载overload都是实现多态的方式。

	2、不同点/区别
		①方法重载要求方法名必须相同，但参数列表必须不同，即方法的参数类型不同、参数个数不同、参数顺序不同，或三者都不同，与反回值类型无关。
		②方法重写则要求子类被重写方法与父类被重写方法有相同的返回值类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常处理。

		③方法重载是编译时的多态性，而实方法重写是运行时的多态性。

		④方法重载发生在一个类中，而方法重写发生在子类与父类之间。
	

mysql服务端下载  https://dev.mysql.com/get/Downloads/MySQL-8.0/mysql-8.0.18-winx64.zip

代理角色通常在将客户端调用传递给真实的主题之前或之后，都要执行某个操作，而不是单纯地将调用传递给真实主题对象

	spring两种代理方式

1、若目标对象实现了若干接口，spring使用JDK的java.lang.reflect.Proxy类代理。 
优点：因为有接口，所以使系统更加松耦合 
缺点：为每一个目标类创建接口

2、若目标对象没有实现任何接口，spring使用CGLIB库生成目标对象的子类。 
优点：因为代理类与目标类是继承关系，所以不需要有接口的存在。 
缺点：因为没有使用接口，所以系统的耦合性没有使用JDK的动态代理好。	

JDK和CGLIB生成动态代理类的区别
关于动态代理和静态代理
当一个对象（客户端）不能或者不想直接引用另一个对象（目标对象），这时可以应用代理模式在这两者之间构建一个桥梁--代理对象。
按照代理对象的创建时期不同，可以分为两种：
静态代理：事先写好代理对象类，在程序发布前就已经存在了；
动态代理：应用程序发布后，通过动态创建代理对象。
静态代理其实就是一个典型的代理模式实现，在代理类中包装一个被代理对象，然后影响被代理对象的行为，比较简单，代码就不放了。
其中动态代理又可分为：JDK动态代理和CGLIB代理。	

JDK和CGLIB生成动态代理类的区别
关于动态代理和静态代理
当一个对象（客户端）不能或者不想直接引用另一个对象（目标对象），这时可以应用代理模式在这两者之间构建一个桥梁--代理对象。
按照代理对象的创建时期不同，可以分为两种：
静态代理：事先写好代理对象类，在程序发布前就已经存在了；
动态代理：应用程序发布后，通过动态创建代理对象。
静态代理其实就是一个典型的代理模式实现，在代理类中包装一个被代理对象，然后影响被代理对象的行为，比较简单，代码就不放了。
其中动态代理又可分为：JDK动态代理和CGLIB代理。
1.JDK动态代理
此时代理对象和目标对象实现了相同的接口，目标对象作为代理对象的一个属性，具体接口实现中，可以在调用目标对象相应方法前后加上其他业务处理逻辑。
代理模式在实际使用时需要指定具体的目标对象，如果为每个类都添加一个代理类的话，会导致类很多，同时如果不知道具体类的话，怎样实现代理模式呢？这就引出动态代理。
JDK动态代理只能针对实现了接口的类生成代理。
2.CGLIB代理
CGLIB（CODE GENERLIZE LIBRARY）代理是针对类实现代理，
主要是对指定的类生成一个子类，覆盖其中的所有方法，所以该类或方法不能声明称final的。
JDK动态代理和CGLIB代理生成的区别
JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。
CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法 。
因为是继承，所以该类或方法最好不要声明成final ，final可以阻止继承和多态。
PS：final 所修饰的数据具有“终态”的特征，表示“最终的”意思：
final 修饰的类不能被继承。
final 修饰的方法不能被子类重写。
final 修饰的变量（成员变量或局部变量）即成为常量，只能赋值一次。
final 修饰的成员变量必须在声明的同时赋值，如果在声明的时候没有赋值，那么只有 一次赋值的机会，而且只能在构造方法中显式赋值，然后才能使用。
final 修饰的局部变量可以只声明不赋值，然后再进行一次性的赋值。
参考代码
CGLIB：
1
2
3
4
5
6
7
8
public Object createProxyObject(Object obj) {
this.targetObject = obj;
Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(obj.getClass());
enhancer.setCallback(this);
Object proxyObj = enhancer.create();
return proxyObj;// 返回代理对象，返回的对象其实就是一个封装了“实现类”的代理类，是实现类的实例。
}
JDK：
1
2
3
4
5
public Object newProxy(Object targetObject) {// 将目标对象传入进行代理
this.targetObject = targetObject; <br> //注意这个方法的参数，后面是类实现的接口
return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),
targetObject.getClass().getInterfaces(), this);// 返回代理对象
}
在代码中可以看到，在生成代理类时，传递的是实现类所实现的接口 targetObject.getClass().getInterfaces()，所以JDK只能对于接口进行做代理。如果换成类的话，则会抛java.lang.ClassCastException异常。
在Spring的源码中，可以看到很多生成代理类的代码。
动态代理的应用
AOP（Aspect-OrientedProgramming，面向切面编程），AOP包括切面（aspect）、通知（advice）、连接点（joinpoint），实现方式就是通过对目标对象的代理在连接点前后加入通知，完成统一的切面操作。
实现AOP的技术，主要分为两大类：
一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；
二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。
Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。
默认的策略是如果目标类是接口，则使用JDK动态代理技术，如果目标对象没有实现接口，则默认会采用CGLIB代理。
如果目标对象实现了接口，可以强制使用CGLIB实现代理（添加CGLIB库，并在spring配置中加入<aop:aspectj-autoproxy proxy-target-class="true"/>）  



---------------------------------------------------------------------------------------------------------------------------------------------
native主要用于方法上，简单介绍如下：
1、一个native方法就是一个Java调用非Java代码的接口。一个native方法是指该方法的实现由非Java语言实现，比如用C或C++实现。
2、在定义一个native方法时，并不提供实现体（比较像定义一个Java Interface），因为其实现体是由非Java语言在外面实现的。
---------------------------------------------------------------------------------------------------------------------------------------------

两个对象hashCode()相同，equals() 也一定为 true吗？
首先，答案肯定是不一定。同时反过来equals为true，hashCode也不一定相同。

类的hashCode方法和equals方法都可以重写，返回的值完全在于自己定义。

?

hashCode()返回该对象的哈希码值；equals()返回两个对象是否相等。

?

关于hashCode和equal是方法是有一些 常规协定 ：

1、两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。

2、两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，亿提搞哈希表性能。

3、重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。
---------------------------------------------------------------------------------------------------------------------------------------------------

向上取整, 运算称为 Ceiling，用数学符号 ??  （上有起止，开口向下）表示,。

向下取整, 运算称为 Floor，用数学符号 ?? （下有起止，开口向上）表示。

向上取整：比自己大的最小整数；
向下取整：比自己小的最大整数；
四舍五入：更接近自己的整数； 把小数点后面的数字四舍五入
即：如被舍去部分的头一位数字小于五，则舍去; 如大于等于五，则被保留部分的最后一位数字加1
、Math.floor() 向下取整，即小于这个数的最大的那个整数
Math.ceil() 向上取整，即大于这个数的最小的那个整数。
加上 0.5 后再向下取整
---------------------------------------------------------------------------------------------------------------------------------------------------